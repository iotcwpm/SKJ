})
names <- c(names,paste0('recruits_deviations(',recdevs$year,').value'))
values <- c(values,recdevs$Value)
#' Selectivity for each method (a.k.a. gear, Fleet)
#' Use the model$selex data.frame which gives calculated values which can be used
#' for the knots in ioskj.
#' Fleets:
#' 	1 = PL
#' 	2 = PSLS
#' 	3 = PSFS
#' 	4 = Other
#' Fleets 5 & 6 are repeats of PL and PSFS for fitting CPUE
selects <- subset(model$sizeselex,Factor=='Lsel' & year==2013 & Fleet %in% c(1,2,4))
# Map fleets into ioskj method codes:
#	PS = 0,
#	PL = 1,
#	GN = 2,
#	OT = 3
selects <- within(selects,{
method <- NA
method[Fleet==2] <- 0 # PSFS -> PS
method[Fleet==1] <- 1 # PL -> PL
method[Fleet==4] <- 3 # Other -> OT
})
# Repeat other row for gill net
selects <- rbind(selects,within(subset(selects,method==3),method<-2))
# Drop uneeded columns
selects$Factor <- NULL
selects$Fleet <- NULL
selects$year <- NULL
selects$gender <- NULL
selects$label <- NULL
# Reshape
selects <- melt(selects,id.vars="method")
selects$variable <- as.numeric(as.character(selects$variable))
# Interpolate selectivity at length of the knots used in ioskj
# Create parameter names and values
knots <- 0:6
for(method in 0:3){
names <- c(names,paste0('selectivities(',method,',',knots,').value'))
values <- c(values,with(subset(selects,method==0),round(approx(x=variable,y=value,(knots*10)+20)$y,6)))
}
names
values
#' Extract parameters from each model
for(index in 1:nrow(runs)){
run <- runs[index,]
print(run$dir)
model <- models[[run$dir]]
names <- NULL
values <- NULL
#' Unfished spawning biomass
#' Use this instead of R0 because it is not dependent upon assumed
#' size/age of recruits or early mortality schedule
b0 <- model$timeseries[1,'SpawnBio']
names <- c(names,'spawners_unfished.value')
values <- c(values,b0)
#' Recruitment deviations
pars <- model$parameters[,c('Label','Value')]
recdevs <- within(pars[grepl('Main_RecrDev',pars$Label),],{
year <- as.numeric(str_match(Label,'Main_RecrDev_(\\d+)')[,2])
})
names <- c(names,paste0('recruits_deviations(',recdevs$year,').value'))
values <- c(values,recdevs$Value)
#' Selectivity for each method (a.k.a. gear, Fleet)
#' Use the model$selex data.frame which gives calculated values which can be used
#' for the knots in ioskj.
#' Fleets:
#' 	1 = PL
#' 	2 = PSLS
#' 	3 = PSFS
#' 	4 = Other
#' Fleets 5 & 6 are repeats of PL and PSFS for fitting CPUE
selects <- subset(model$sizeselex,Factor=='Lsel' & year==2013 & Fleet %in% c(1,2,4))
# Map fleets into ioskj method codes:
#	PS = 0,
#	PL = 1,
#	GN = 2,
#	OT = 3
selects <- within(selects,{
method <- NA
method[Fleet==2] <- 0 # PSFS -> PS
method[Fleet==1] <- 1 # PL -> PL
method[Fleet==4] <- 3 # Other -> OT
})
# Repeat other row for gill net
selects <- rbind(selects,within(subset(selects,method==3),method<-2))
# Drop uneeded columns
selects$Factor <- NULL
selects$Fleet <- NULL
selects$year <- NULL
selects$gender <- NULL
selects$label <- NULL
# Reshape
selects <- melt(selects,id.vars="method")
selects$variable <- as.numeric(as.character(selects$variable))
# Interpolate selectivity at length of the knots used in ioskj
# Create parameter names and values
knots <- 0:6
for(method in 0:3){
names <- c(names,paste0('selectivities(',method,',',knots,').value'))
values <- c(values,with(subset(selects,method==0),round(approx(x=variable,y=value,(knots*10)+20)$y,6)))
}
runs[index,names] <- values
}
#' Extract parameters from each model
for(index in 1:nrow(runs)){
run <- runs[index,]
print(run$dir)
model <- models[[run$dir]]
names <- NULL
values <- NULL
#' Unfished spawning biomass
#' Use this instead of R0 because it is not dependent upon assumed
#' size/age of recruits or early mortality schedule
b0 <- model$timeseries[1,'SpawnBio']
names <- c(names,'spawners_unfished.value')
values <- c(values,b0)
#' Recruitment deviations
pars <- model$parameters[,c('Label','Value')]
recdevs <- within(pars[grepl('Main_RecrDev',pars$Label),],{
year <- as.numeric(str_match(Label,'Main_RecrDev_(\\d+)')[,2])
})
names <- c(names,paste0('recruits_deviations(',recdevs$year,').value'))
values <- c(values,recdevs$Value)
#' Selectivity for each method (a.k.a. gear, Fleet)
#' Use the model$selex data.frame which gives calculated values which can be used
#' for the knots in ioskj.
#' Fleets:
#' 	1 = PL
#' 	2 = PSLS
#' 	3 = PSFS
#' 	4 = Other
#' Fleets 5 & 6 are repeats of PL and PSFS for fitting CPUE
selects <- subset(model$sizeselex,Factor=='Lsel' & year==2013 & Fleet %in% c(1,2,4))
# Map fleets into ioskj method codes:
#	PS = 0,
#	PL = 1,
#	GN = 2,
#	OT = 3
selects <- within(selects,{
method <- NA
method[Fleet==2] <- 0 # PSFS -> PS
method[Fleet==1] <- 1 # PL -> PL
method[Fleet==4] <- 3 # Other -> OT
})
# Repeat other row for gill net
selects <- rbind(selects,within(subset(selects,method==3),method<-2))
# Drop uneeded columns
selects$Factor <- NULL
selects$Fleet <- NULL
selects$year <- NULL
selects$gender <- NULL
selects$label <- NULL
# Reshape
selects <- melt(selects,id.vars="method")
selects$variable <- as.numeric(as.character(selects$variable))
# Interpolate selectivity at length of the knots used in ioskj
# Create parameter names and values
knots <- 0:6
for(method in 0:3){
names <- c(names,paste0('selectivities(',method,',',knots,').value'))
values <- c(values,with(subset(selects,method==0),round(approx(x=variable,y=value,(knots*10)+20)$y,6)))
}
#runs[index,names] <- values
}
pars_ <- as.data.frame(matrix(values,nrow=1))
names(pars_) <- names
pars <- NULL
for(index in 1:nrow(runs)){
run <- runs[index,]
print(run$dir)
model <- models[[run$dir]]
names <- NULL
values <- NULL
#' Unfished spawning biomass
#' Use this instead of R0 because it is not dependent upon assumed
#' size/age of recruits or early mortality schedule
b0 <- model$timeseries[1,'SpawnBio']
names <- c(names,'spawners_unfished.value')
values <- c(values,b0)
#' Recruitment deviations
pars <- model$parameters[,c('Label','Value')]
recdevs <- within(pars[grepl('Main_RecrDev',pars$Label),],{
year <- as.numeric(str_match(Label,'Main_RecrDev_(\\d+)')[,2])
})
names <- c(names,paste0('recruits_deviations(',recdevs$year,').value'))
values <- c(values,recdevs$Value)
#' Selectivity for each method (a.k.a. gear, Fleet)
#' Use the model$selex data.frame which gives calculated values which can be used
#' for the knots in ioskj.
#' Fleets:
#' 	1 = PL
#' 	2 = PSLS
#' 	3 = PSFS
#' 	4 = Other
#' Fleets 5 & 6 are repeats of PL and PSFS for fitting CPUE
selects <- subset(model$sizeselex,Factor=='Lsel' & year==2013 & Fleet %in% c(1,2,4))
# Map fleets into ioskj method codes:
#	PS = 0,
#	PL = 1,
#	GN = 2,
#	OT = 3
selects <- within(selects,{
method <- NA
method[Fleet==2] <- 0 # PSFS -> PS
method[Fleet==1] <- 1 # PL -> PL
method[Fleet==4] <- 3 # Other -> OT
})
# Repeat other row for gill net
selects <- rbind(selects,within(subset(selects,method==3),method<-2))
# Drop uneeded columns
selects$Factor <- NULL
selects$Fleet <- NULL
selects$year <- NULL
selects$gender <- NULL
selects$label <- NULL
# Reshape
selects <- melt(selects,id.vars="method")
selects$variable <- as.numeric(as.character(selects$variable))
# Interpolate selectivity at length of the knots used in ioskj
# Create parameter names and values
knots <- 0:6
for(method in 0:3){
names <- c(names,paste0('selectivities(',method,',',knots,').value'))
values <- c(values,with(subset(selects,method==0),round(approx(x=variable,y=value,(knots*10)+20)$y,6)))
}
pars_ <- as.data.frame(matrix(values,nrow=1))
names(pars_) <- names
pars <- rbind(pars,pars_)
}
runs <- cbind(runs,pars)
pars
pars <- NULL
for(index in 1:nrow(runs)){
run <- runs[index,]
print(run$dir)
model <- models[[run$dir]]
names <- NULL
values <- NULL
#' Unfished spawning biomass
#' Use this instead of R0 because it is not dependent upon assumed
#' size/age of recruits or early mortality schedule
b0 <- model$timeseries[1,'SpawnBio']
names <- c(names,'spawners_unfished.value')
values <- c(values,b0)
#' Recruitment deviations
temp <- model$parameters[,c('Label','Value')]
recdevs <- within(temp[grepl('Main_RecrDev',temp$Label),],{
year <- as.numeric(str_match(Label,'Main_RecrDev_(\\d+)')[,2])
})
names <- c(names,paste0('recruits_deviations(',recdevs$year,').value'))
values <- c(values,recdevs$Value)
#' Selectivity for each method (a.k.a. gear, Fleet)
#' Use the model$selex data.frame which gives calculated values which can be used
#' for the knots in ioskj.
#' Fleets:
#' 	1 = PL
#' 	2 = PSLS
#' 	3 = PSFS
#' 	4 = Other
#' Fleets 5 & 6 are repeats of PL and PSFS for fitting CPUE
selects <- subset(model$sizeselex,Factor=='Lsel' & year==2013 & Fleet %in% c(1,2,4))
# Map fleets into ioskj method codes:
#	PS = 0,
#	PL = 1,
#	GN = 2,
#	OT = 3
selects <- within(selects,{
method <- NA
method[Fleet==2] <- 0 # PSFS -> PS
method[Fleet==1] <- 1 # PL -> PL
method[Fleet==4] <- 3 # Other -> OT
})
# Repeat other row for gill net
selects <- rbind(selects,within(subset(selects,method==3),method<-2))
# Drop uneeded columns
selects$Factor <- NULL
selects$Fleet <- NULL
selects$year <- NULL
selects$gender <- NULL
selects$label <- NULL
# Reshape
selects <- melt(selects,id.vars="method")
selects$variable <- as.numeric(as.character(selects$variable))
# Interpolate selectivity at length of the knots used in ioskj
# Create parameter names and values
knots <- 0:6
for(method in 0:3){
names <- c(names,paste0('selectivities(',method,',',knots,').value'))
values <- c(values,with(subset(selects,method==0),round(approx(x=variable,y=value,(knots*10)+20)$y,6)))
}
pars_ <- as.data.frame(matrix(values,nrow=1))
names(pars_) <- names
pars <- rbind(pars,pars_)
}
runs <- cbind(runs,pars)
pars
names
temp <- model$parameters[,c('Label','Value')]
recdevs <- within(temp[grepl('Main_RecrDev',temp$Label),],{
year <- as.numeric(str_match(Label,'Main_RecrDev_(\\d+)')[,2])
})
recdevs
model$parameters
recdevs
merge(data.frame(year=1985:2010),recdevs)
merge(data.frame(year=1985:2010),recdevs,all.x=T)
recdevs$Value[is.na(recdevs$Value)] <- 0
#' Extract parameters from each model
pars <- NULL
for(index in 1:nrow(runs)){
run <- runs[index,]
print(run$dir)
model <- models[[run$dir]]
names <- NULL
values <- NULL
#' Unfished spawning biomass
#' Use this instead of R0 because it is not dependent upon assumed
#' size/age of recruits or early mortality schedule
b0 <- model$timeseries[1,'SpawnBio']
names <- c(names,'spawners_unfished.value')
values <- c(values,b0)
#' Recruitment deviations
temp <- model$parameters[,c('Label','Value')]
recdevs <- within(temp[grepl('Main_RecrDev',temp$Label),],{
year <- as.numeric(str_match(Label,'Main_RecrDev_(\\d+)')[,2])
})
# Ensure the correct number of years of recdevs
recdevs <- merge(data.frame(year=1985:2010),recdevs,all.x=T){
recdevs$Value[is.na(recdevs$Value)] <- 0
names <- c(names,paste0('recruits_deviations(',recdevs$year,').value'))
values <- c(values,recdevs$Value)
#' Selectivity for each method (a.k.a. gear, Fleet)
#' Use the model$selex data.frame which gives calculated values which can be used
#' for the knots in ioskj.
#' Fleets:
#' 	1 = PL
#' 	2 = PSLS
#' 	3 = PSFS
#' 	4 = Other
#' Fleets 5 & 6 are repeats of PL and PSFS for fitting CPUE
selects <- subset(model$sizeselex,Factor=='Lsel' & year==2013 & Fleet %in% c(1,2,4))
# Map fleets into ioskj method codes:
#	PS = 0,
#	PL = 1,
#	GN = 2,
#	OT = 3
selects <- within(selects,{
method <- NA
method[Fleet==2] <- 0 # PSFS -> PS
method[Fleet==1] <- 1 # PL -> PL
method[Fleet==4] <- 3 # Other -> OT
})
# Repeat other row for gill net
selects <- rbind(selects,within(subset(selects,method==3),method<-2))
# Drop uneeded columns
selects$Factor <- NULL
selects$Fleet <- NULL
selects$year <- NULL
selects$gender <- NULL
selects$label <- NULL
# Reshape
selects <- melt(selects,id.vars="method")
selects$variable <- as.numeric(as.character(selects$variable))
# Interpolate selectivity at length of the knots used in ioskj
# Create parameter names and values
knots <- 0:6
for(method in 0:3){
names <- c(names,paste0('selectivities(',method,',',knots,').value'))
values <- c(values,with(subset(selects,method==0),round(approx(x=variable,y=value,(knots*10)+20)$y,6)))
}
pars_ <- as.data.frame(matrix(values,nrow=1))
names(pars_) <- names
pars <- rbind(pars,pars_)
}
#' Extract parameters from each model
pars <- NULL
for(index in 1:nrow(runs)){
run <- runs[index,]
print(run$dir)
model <- models[[run$dir]]
names <- NULL
values <- NULL
#' Unfished spawning biomass
#' Use this instead of R0 because it is not dependent upon assumed
#' size/age of recruits or early mortality schedule
b0 <- model$timeseries[1,'SpawnBio']
names <- c(names,'spawners_unfished.value')
values <- c(values,b0)
#' Recruitment deviations
temp <- model$parameters[,c('Label','Value')]
recdevs <- within(temp[grepl('Main_RecrDev',temp$Label),],{
year <- as.numeric(str_match(Label,'Main_RecrDev_(\\d+)')[,2])
})
# Ensure the correct number of years of recdevs
recdevs <- merge(data.frame(year=1985:2010),recdevs,all.x=T)
recdevs$Value[is.na(recdevs$Value)] <- 0
names <- c(names,paste0('recruits_deviations(',recdevs$year,').value'))
values <- c(values,recdevs$Value)
#' Selectivity for each method (a.k.a. gear, Fleet)
#' Use the model$selex data.frame which gives calculated values which can be used
#' for the knots in ioskj.
#' Fleets:
#' 	1 = PL
#' 	2 = PSLS
#' 	3 = PSFS
#' 	4 = Other
#' Fleets 5 & 6 are repeats of PL and PSFS for fitting CPUE
selects <- subset(model$sizeselex,Factor=='Lsel' & year==2013 & Fleet %in% c(1,2,4))
# Map fleets into ioskj method codes:
#	PS = 0,
#	PL = 1,
#	GN = 2,
#	OT = 3
selects <- within(selects,{
method <- NA
method[Fleet==2] <- 0 # PSFS -> PS
method[Fleet==1] <- 1 # PL -> PL
method[Fleet==4] <- 3 # Other -> OT
})
# Repeat other row for gill net
selects <- rbind(selects,within(subset(selects,method==3),method<-2))
# Drop uneeded columns
selects$Factor <- NULL
selects$Fleet <- NULL
selects$year <- NULL
selects$gender <- NULL
selects$label <- NULL
# Reshape
selects <- melt(selects,id.vars="method")
selects$variable <- as.numeric(as.character(selects$variable))
# Interpolate selectivity at length of the knots used in ioskj
# Create parameter names and values
knots <- 0:6
for(method in 0:3){
names <- c(names,paste0('selectivities(',method,',',knots,').value'))
values <- c(values,with(subset(selects,method==0),round(approx(x=variable,y=value,(knots*10)+20)$y,6)))
}
pars_ <- as.data.frame(matrix(values,nrow=1))
names(pars_) <- names
pars <- rbind(pars,pars_)
}
pars
runs <- cbind(runs,pars)
head(runs)
pars$m <- runs$m
pars$h <- runs$h
write.table(pars,file='pars.tsv',col.names=T,row.names=F,quote=F)
write.table(runs,file='runs',col.names=T,row.names=F,quote=F)
write.table(runs,file='runs.tsv',col.names=T,row.names=F,quote=F)
source('~/Trophia/Code/ioskj/ss3/ss3.R')
write.table(runs,file='runs.tsv',col.names=T,row.names=F,quote=F,sep='\t')
write.table(pars,file='pars.tsv',col.names=T,row.names=F,quote=F,sep='\t')
pars$mortality_base.value <- runs$m
pars$recruits_steepness.value <- runs$h
# Write to file
write.table(runs,file='runs.tsv',col.names=T,row.names=F,quote=F,sep='\t')
write.table(pars,file='pars.tsv',col.names=T,row.names=F,quote=F,sep='\t')
runs$m <- NULL
runs$h <- NULL
write.table(runs,file='runs.tsv',col.names=T,row.names=F,quote=F,sep='\t')
write.table(pars,file='pars.tsv',col.names=T,row.names=F,quote=F,sep='\t')
runs$m <- NULL
source('~/Trophia/Code/ioskj/ss3/ss3.R')
setwd("~/Trophia/Code/ioskj/ss3/display")
source('../../common.R',local=T)
require(stringr)
load(c(
'samples'
),from='../output')
plot_densities <- function(param){
print(
ggplot(data.frame(value=samples[,name]),aes(x=value)) +
geom_density(adjust=1/2,alpha=0.2) +
labs(x="Value",y="Density")
)
}
head(samples)
plot_densities <- function(param){
print(
ggplot(data.frame(value=samples[,paste0(param,'.value')]),aes(x=value)) +
geom_density(adjust=1/2,alpha=0.2) +
labs(x="Value",y="Density")
)
}
plot_densities('mortality_base')
names(samples)
Geom_hist
geom_hist
geom_bar
plot_densities <- function(param){
print(
ggplot(data.frame(
value = samples[,paste0(param,'.value')]
m = samples$mortality_base.value]
)) +
geom_bar(aes(x=value,fill=mortality_base)) +
labs(x="Value",y="Density")
)
}
plot_densities <- function(param){
print(
ggplot(data.frame(
value = samples[,paste0(param,'.value')],
m = samples$mortality_base.value
)) +
geom_bar(aes(x=value,fill=mortality_base)) +
labs(x="Value",y="Density")
)
}
?geom_bar
